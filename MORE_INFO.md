Insights processing background
==============================

How data is processed in Insights
---------------------------------

Rules base their decisions on data from a client system.  This takes the form
of configuration files, log or status files, and command output.  For
example, many rules want to check the contents of the `/var/log/messages`
file.  How do you get access to that?

Here's a rough flow-chart of how data gets through Insights:

```
  +----------------+   +----------------+
  | Raw input file |   | Command output |
  +----------------+   +----------------+
                   |   |
              +----v---v----+
              |  File spec  |
              +------+------+
                     |
                +----v------+
                | Parser(s) |
                +----+------+----------+
                     |                 |
                     |          +------v------+
                     |          | Combiner(s) |
                     |          +------+------+
                     |                 |
                     +-----------------+
                     |
    +----------------v--+------------------+
    |                   |                  |
+---v----+         +----v---+         +----v---+
|  Rule  |         |  Rule  |         |  Rule  |
+--------+         +--------+         +--------+
```

The **File spec**, defined in `insights-core/insights/config/specs.py`,
encapsulates one or more sources of the same information. In its simplest
form, it's a single source - but it can incorporate multiple sources in a
variety of ways.  Let's look at a simple one, the spec for getting the
configuration file for `sshd`:

```python
    "sshd_config"               : SimpleFileSpec("etc/ssh/sshd_config"),
```

A **SimpleFileSpec** collects one file; a **CommandSpec** collects the output
of one command:

```python
    "sysctl"                    : CommandSpec("/sbin/sysctl -a"),
```

Some specs, such as **PatternSpec**, collect multiple files:

```python
    "sssd_logs"                 : PatternSpec(r"var/log/sssd/.*\.log$"),
```

Likewise, a spec can define multiple ways to collect the information it seeks:

```python
    "ss"                        : First([CommandSpec("/usr/sbin/ss -tulpn"),
                                    SimpleFileSpec("ss"),
                                    SimpleFileSpec("sos_commands/foreman/foreman-debug/ss")]),
```

This spec tries to collect the command output of ``/usr/sbin/ss -tulpn``.  If
that isn't available, then it looks for a file called ``ss``, and finally for
a file called ``sos_commands/foreman/foreman-debug/ss``, underneath the path
given to the CLI.  There are many other variations on this idea in the
specs definitions.

CommandSpecs automatically recognise the command output from the file name
format generated by ``sosreport``, as well as guiding the Insights client to
run the given command.

Parsers and Combiners
---------------------

Each parser (in `insights-core/insights/parsers`) uses a decorator to
declare that it reads the content from a particular spec:

```:python
@parser('smartctl')
class SMARTctl(Parser):
```

Parsers take the raw data from the commands, configuration and log files and
turn it into useful, searchable information.  For example, the `SMARTctl`
parser reads information such as the overall health assessment for the drive
and makes it available as a property:

```python
>>> drive.health
'PASSED'
```

It's much easier to write a rule using the parsed output of a file rather
than having to parse the output directly.  Likewise, it saves a considerable
amount of work to only parse the file once, rather than many rules each
reading the `/var/log/messages` file themselves.

Parsers are limited to parsing the output of one file or command.  Each
object of the class stores the result of parsing one specific file.  However,
specs using 'PatternSpec' always see multiple files.  Those items turn up
as individual instances of the Parser class (see below), but fundamentally
they are drawn from one source spec.

There are, however, situations where data from several source needs to be
drawn together into one object.  For these situations Insights uses
*Combiners*.

Combiners work in many ways like rules.  Instead of being bound to one
spec, they are based on the output of one or more parsers.  They use a
similar 'requires' syntax to rule declaration:

```python
@combiner(requires=[LimitsConf])
class AllLimitsConf(object):
```

A combiner can be based on one or more parsers, and can list both required
and optional parsers.  This allows for several usage scenarios:

* Drawing together all the files from a PatternSpec object and presents
  them as one item - e.g. the `AllLimitsConf` combiner.
* Reading parsers relevant to different operating system versions or tools to
  provide a unified view of configuration - e.g. the `Services` combiner.
* Reading multiple parsers to build up a detailed picture of one feature of
  the operating system - e.g. the `IPv6` combiner.

All parsers and combiners are listed in catalogues by module name:

* [Shared Parsers Catalogue](http://insights-core.readthedocs.io/en/latest/parsers_index.html)
* [Shared Combiners Catalogue](http://insights-core.readthedocs.io/en/latest/combiners_index.html)

### Local and shared parsers

In the beginning, Insights was created.  At that time every rule defined its
own parsers.  However, it was quickly found to cause three problems:

* Lots of copy-and-paste parsing code leading to duplication of coding effort.
* Many rules reading the same file in slightly different ways leading to
  duplication of processing effort.
* Rules now had to know which spec defined a particular input file or command,
  which was confusing.

This caused the creation of 'shared' parsers, which would do the processing
work once and could then be drawn on by multiple rules.  Rules can still
define their own local parser but this is highly discouraged.  However, you
can still see vestiges of this in the `local` and `shared` arguments to the
rule function.

Rules and Conditions
--------------------

So now you've worked out which parsers and/or combiners you need to use for
your rule.  Rules have a basic template:

```
"""
Rule description # [1]
"""
from insights.core.plugins import make_response, rule # [2]
from insights.parsers.some_parser import Parser_Class # [3]

ERROR_KEY = 'SOME_UNIQUE_UPPER_CASE_UNDERSCORED_STRING' # [4]


@rule(requires=[Parser_Class]) # [5]
def rule_name(local, shared): # [6]
    """
    Description of logic in rule # [7]
    """

    info = shared[Parser_Class] # [8]
    if the conditions that cause the problem to occur are all true: # [9]
        return make_response( # [10]
            ERROR_KEY, # [11]
            keyed_information=data_from_parsers, # [12]
        )
```

Parts of a rule annotated above are:

* `[1]` (Edit) The rule description, as handy documentation.
* `[2]` The import of the `make_response` function and `rule` decorator.
* `[3]` (Edit) One or more parser or combiner imports.
* `[4]` (Edit) An error key.  This uniquely identifies this error across
  the history of the rule.  Historically this is comprised of upper case
  letters and underscores, in a single word.
* `[5]` (Edit) The rule definition, requiring one or more parsers or
  combiners.
* `[6]` (Edit) The rule function.  It must take the two parameters `local`
  and `shared`.
* `[7]` (Edit) Documentation of the actual logic of the rule, to explain
  how it pulls all the information together and what it does with it.
* `[8]` (Edit) Drawing information from the shared parser dictionary.
* `[9]` (Edit) The actual code.  This will almost always be multiple lines.
* `[10]` Returning the result of the `make_response` function.
* `[11]` The error key must be the first parameter to the `make_response`
  function.
* `[12]` (Edit) Further key-value pairs of information to return to the user.

You can see this basic process made easy for you in the
`create_insights_rule.sh` script.  Simply give it a rule name in lower case
and it will generate the rule and its associated test file (more on that
later) automatically.

Rule functions always take two parameters - `local` and `shared`, as
explained above.

If the rule does not return the result of `make_response`, then it is assumed
to not produce any output.
